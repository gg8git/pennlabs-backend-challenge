# Open-Ended Questions

## 1.
Most likely, any Penn-affiliated web application will have to use the PennID login system. Unfortunately, I am not sure how that works. However, in general, you would likely need to create a few routes for new user registration, user login, and user logout. On the backend, you would likely just create a new user every time someone logs in, store all their information, and encrypt their password of choice. On each subsequent login, you could verify their identity through the password check, and, since all their information is stored in the system, allow them to pick up where they left off. Logout probably is not that complicated. On top of this, on the frontend side, you probably need some base pages for login/registration and then some redirect link (maybe back to the login page) when they logout. 

The previous web application I created had some security issues because the web API was open and accessible to anyone who knew the routes. However, you could create an authentication system where any API request is first authenticated via an API key, OAuth2, or something else of the sort. Furthermore, by ensuring that no private information is returned by the API (i.e. passwords), we can ensure that even if outsiders can access the web API, they won't be able to get anyone's login credentials.

I thought this was actually quite interesting, so I did some research and wrote some of the routes I think you would need to make this work. I have never personally worked with authentication before, so perhaps someone can check my work lol

## 2.
This question is funny because I implemented the Review class, and then I read the write up questions, and then I realized that everyone looking at this technical will think I just tried to implement comments (but badly, because you can't reply). Anyway, because I've already done the work to deal with reviews on clubs, I imagine that comments on top of this will just be a way for people to reply to certain reviews and add to the conversation underneath reviews rather than to serve as a standalone feature (I think this actually makes quite a lot of sense given that you may want further clarification on someone's review or opinion on a club). 

In that case, I would create two more classes, and slightly tweak the Review class I have right now. In particular, I would first create one overarching class called Comment(db.Model) that has all the ID, description, and user fields. Then, I would change the Review class to be Review(Comment), and add the title, rating, and club fields. Then, I would add a Reply(Comment) class which just has an additional comment field. Finally, I would add a one-to-many field under Comment(db.Model) called replies where comments can be stacked on under other comments (think of reddit). 

I hope that makes sense lol. I think that's actually a pretty cool idea, and I would implement it to see if the inheritance would work, but I am very short on time so maybe I'll look at it after my submission.

## 3.
In terms of route-caching, I'm not completely sure how the actual Penn Club website does it, but I would most likely cache all the club routes (or at least some of them), maybe all the tag routes, and probably nothing else (even as the site grows to have comment routes and such). In particular, this is because I think new users can join all the time and new comments can be made all the time, whereas the number of clubs and tags probably stays roughly constant (with the exception of at the beginning or end of a semester). This means a few things. First, it would not make sense to cache any of the comments or users, because they change too often. Second, just caching the tags seems kind of useless, so you might as well cache the clubs if you're going to cache anything at all. 

In particular, in regards to cache invalidation and management, I think it would likely be fine to run some time-based expiration model, where caches are updated once every [insert long period of time] (maybe days? hours? I'm not sure how often caching is done at a production scale). This is, except for the comments and reviews of clubs. I think this issue could be handled by making it so that each club api route only stores a few main reviews (maybe three that sort of encompass the vibe of all the reviews), except for the actual /api/clubs/club_name/reviews route, which stores all of the reviews and isn't cached. I imagine this like how Amazon has a page with the product and a PREVIEW of the reviews, and then a separate page that you click into that loads all of the reviews. Potentially, instead of doing a time-based expiration model, we could do an event-based expiration model, where, everytime a club is added, then the club cache routes are updated. But, that may be slightly more complicated.

Finally, in terms of the actual Python implementation, I know that caching packages like the flask_caching extension are out there and Django has some cache_page package as well, but I have never used either, so I would probably have to read some documentation, watch some tutorials, and then try and figure out how those work.
